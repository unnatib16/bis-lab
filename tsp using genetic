import numpy as np
import random

# Example cities (x, y coordinates)
cities = np.array([
    [0, 0],
    [1, 5],
    [5, 2],
    [6, 6],
    [8, 3],
    [7, 7],
    [2, 8],
    [3, 3]
])

num_cities = len(cities)
population_size = 100
num_generations = 200
mutation_rate = 0.1
tournament_size = 5

# Calculate distance matrix
def calc_distance_matrix(cities):
    n = len(cities)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            dist_matrix[i, j] = np.linalg.norm(cities[i] - cities[j])
    return dist_matrix

distance_matrix = calc_distance_matrix(cities)

# Fitness function: inverse of total route distance
def fitness(route):
    dist = 0
    for i in range(num_cities):
        dist += distance_matrix[route[i], route[(i+1) % num_cities]]
    return 1 / dist

# Initialize population with random permutations
def init_population():
    population = []
    for _ in range(population_size):
        individual = list(range(num_cities))
        random.shuffle(individual)
        population.append(individual)
    return population

# Tournament selection
def tournament_selection(population, fitnesses):
    selected = []
    for _ in range(population_size):
        competitors = random.sample(range(population_size), tournament_size)
        competitor_fitnesses = [fitnesses[i] for i in competitors]
        winner_idx = competitors[np.argmax(competitor_fitnesses)]
        selected.append(population[winner_idx])
    return selected

# Order Crossover (OX)
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
   
    child = [None]*size
    # Copy slice from parent1
    child[start:end+1] = parent1[start:end+1]
   
    # Fill remaining positions with genes from parent2
    p2_pointer = 0
    for i in range(size):
        if child[i] is None:
            while parent2[p2_pointer] in child:
                p2_pointer += 1
            child[i] = parent2[p2_pointer]
    return child

# Mutation - swap mutation
def mutate(route):
    route = route.copy()
    if random.random() < mutation_rate:
        i, j = random.sample(range(num_cities), 2)
        route[i], route[j] = route[j], route[i]
    return route

# Main GA loop
population = init_population()
best_route = None
best_fitness = -np.inf

for generation in range(num_generations):
    fitnesses = [fitness(ind) for ind in population]
   
    # Track best solution
    max_idx = np.argmax(fitnesses)
    if fitnesses[max_idx] > best_fitness:
        best_fitness = fitnesses[max_idx]
        best_route = population[max_idx]
   
    # Print progress every 20 generations
    if generation % 20 == 0:
        print(f"Gen {generation}: Best route distance = {1/best_fitness:.4f}")
   
    # Selection
    selected = tournament_selection(population, fitnesses)
   
    # Crossover to create next generation
    next_generation = []
    for i in range(0, population_size, 2):
        parent1 = selected[i]
        parent2 = selected[(i+1) % population_size]
        child1 = crossover(parent1, parent2)
        child2 = crossover(parent2, parent1)
        next_generation.extend([child1, child2])
   
    # Mutation
    population = [mutate(ind) for ind in next_generation]

print("\nBest route found:", best_route)
print(f"Shortest distance: {1/best_fitness:.4f}")
